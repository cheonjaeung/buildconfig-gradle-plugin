/*
 * Copyright 2022 Jaewoong Cheon
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.woong.buildconfig

import com.squareup.javapoet.FieldSpec
import com.squareup.javapoet.JavaFile
import com.squareup.javapoet.MethodSpec
import com.squareup.javapoet.TypeName
import com.squareup.javapoet.TypeSpec
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import java.io.File
import javax.lang.model.element.Modifier

abstract class GenBuildConfigTask : DefaultTask() {
    @get:Input
    abstract var packageName: String

    @get:Input
    abstract var className: String

    @get:Input
    abstract var fields: List<Field>

    @get:OutputDirectory
    abstract var outputDir: File

    @TaskAction
    fun execute() {
        val fieldSpecs = mutableListOf<FieldSpec>()
        for (field in fields) {
            fieldSpecs.add(fieldSpecOf(field.type, field.name, field.value))
        }

        val privateConstructorSpec = MethodSpec
            .constructorBuilder()
            .addModifiers(Modifier.PRIVATE)
            .build()

        val classSpec = TypeSpec
            .classBuilder(className)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addMethod(privateConstructorSpec)
            .addFields(fieldSpecs)
            .build()

        val fileSpec = JavaFile
            .builder(packageName, classSpec)
            .addFileComment("This file is generated by build config gradle plugin. Do not modify it.")
            .build()

        fileSpec.writeTo(outputDir)
    }

    private fun fieldSpecOf(type: FieldType, name: String, value: String): FieldSpec {
        val javaPoetType = when (type) {
            FieldType.BOOLEAN -> TypeName.BOOLEAN
            FieldType.BYTE -> TypeName.BYTE
            FieldType.SHORT -> TypeName.SHORT
            FieldType.INT -> TypeName.INT
            FieldType.LONG -> TypeName.LONG
            FieldType.FLOAT -> TypeName.FLOAT
            FieldType.DOUBLE -> TypeName.DOUBLE
            FieldType.CHAR -> TypeName.CHAR
            else -> null
        }

        return if (javaPoetType != null) {
            FieldSpec
                .builder(javaPoetType, name)
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .initializer(value)
                .build()
        } else if (type == FieldType.STRING) {
            FieldSpec
                .builder(String::class.java, name)
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .initializer(value)
                .build()
        } else {
            throw IllegalArgumentException("Not supported type.")
        }
    }
}
